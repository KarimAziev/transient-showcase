#+TITLE: Transient Showcase
#+AUTHOR: Psionik K
#+PROPERTY: header-args :results silent

Code examples for interactive explanations of [[https://github.com/magit/transient][transient]].

This guide assumes you have minimal knowledge of Emacs, some programming
experience in elisp and non-lisp languages, and have at least seen [[https://magit.vc/screenshots/][screenshots]]
of =magit=.

* How to use
  
  - Open this file in Emacs and run examples as literate org
  - Install the package to run commands and read their source

  If you open this file in Emacs, it will switch to Org mode and you can run
  individual source blocks with =org-babel-execute-src-blk= on the block.

  If you install the package, you can read source for each example with the
  normal.  =describe-function= command.  All commands are under =ts-*= prefix.
  Somewhat useful suffixes are under =ts-suffix-*= while less useful ones under
  =ts--*=.  They will come in handly when you are developing new applications.

  While this file is also the README for this repository, it's not intended to be used
  copy-paste.  Many links will only open in Emacs.  Some definitions are
  included by refrence from [[*Preludes][Preludes]]

** Running Examples in Org Mode

   This is a basic transient, using an anonymous lambda interactive command as
   its only suffix.

  #+begin_src elisp :tangle yes

    (transient-define-prefix ts-hello ()
      "A Transient Prefix"
      [("s" "call suffix"
        (lambda ()
          (interactive)
          (message "Called a suffix")))])

    ;; First, use M-x org-babel-execute-src-blk to cause `ts-hello' to be defined
    ;; Second, M-x `eval-last-sexp' with your point at the end of the line below
    ;; (ts-hello)

  #+end_src

  After executing the block above, you can =execute-extended-command= (*M-x*)
  and select =ts-hello= to show this transient.  All transient prefixes are also
  commands that show up in (*M-x*)
   
* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include siblings
:END:
:CONTENTS:
- [[#terminology][Terminology]]
  - [[#prefixes-and-suffixes][Prefixes and Suffixes]]
    - [[#conceptual-similarity-to-emacs-prefix-arguments][Conceptual similarity to Emacs prefix arguments]]
  - [[#nesting-prefixes][Nesting Prefixes]]
  - [[#infix][Infix]]
  - [[#summary][Summary]]
- [[#declaring---equivalent-forms][Declaring - Equivalent Forms]]
  - [[#the-shorthand-form][The Shorthand form]]
  - [[#keyword-arguments-style][Keyword Arguments Style]]
  - [[#macro-child-definition-style][Macro Child Definition Style]]
  - [[#overriding-in-the-prefix-definition][Overriding in the prefix definition]]
  - [[#quoting-note-for-vectors][Quoting Note for Vectors]]
- [[#groups--layouts][Groups & Layouts]]
  - [[#layouts][Layouts]]
    - [[#groups-one-on-top-of-the-other][Groups one on top of the other]]
    - [[#groups-side-by-side][Groups side by side]]
    - [[#group-on-top-of-groups-side-by-side][Group on top of groups side by side]]
    - [[#empty-strings-make-spaces][Empty strings make spaces]]
  - [[#manually-setting-group-class][Manually setting group class]]
  - [[#descriptions][Descriptions]]
    - [[#dynamic-descriptions][Dynamic Descriptions]]
- [[#nesting--flow-control][Nesting & Flow Control]]
  - [[#single-versus-multiple-commands][Single versus multiple commands]]
  - [[#nesting][Nesting]]
    - [[#binding-a-sub-prefix][Binding a Sub-Prefix]]
      - [[#nesting-with-multiple-commands][Nesting with multiple commands]]
    - [[#setting-up-another-transient-manually][Setting up another transient manually]]
      - [[#errata][Errata]]
  - [[#mixing-interactive][Mixing Interactive]]
    - [[#early-completion][Early completion]]
  - [[#pre-commands-explained][Pre-Commands Explained]]
    - [[#warning][Warning!]]
- [[#using--managing-states][Using & Managing States]]
  - [[#infixes][Infixes]]
    - [[#basic-infixes][Basic Infixes]]
    - [[#reading-infix-values][Reading Infix Values]]
  - [[#scope][Scope]]
    - [[#errata-with-prefix-arg-c-u-universal-argument][Errata with prefix arg (C-u universal argument).]]
  - [[#prefix-value--history][Prefix Value & History]]
- [[#controlling-clis][Controlling CLI's]]
  - [[#reading-arguments-within-suffixes][Reading arguments within suffixes]]
  - [[#switches--arguments][Switches & Arguments]]
    - [[#default-values][Default Values]]
    - [[#argument-and-switch-macros][Argument and Switch Macros]]
    - [[#choices][Choices]]
      - [[#choices-shorthand-in-prefix-definition][Choices shorthand in prefix definition]]
    - [[#mutually-exclusive-switches][Mutually Exclusive Switches]]
    - [[#incompatible-switches][Incompatible Switches]]
    - [[#short-args][Short Args]]
    - [[#choices-from-a-function][Choices from a function]]
  - [[#dispatching-args-into-a-process][Dispatching args into a process]]
  - [[#lisp-variables][Lisp Variables]]
- [[#controlling-visibility][Controlling Visibility]]
  - [[#predicates][Predicates]]
  - [[#inapt-temporarily-unavailable][Inapt (Temporarily Unavailable)]]
    - [[#documentation-in-manaual-missing][Documentation in manaual missing]]
  - [[#levels][Levels]]
    - [[#defining-group--suffix-levels][Defining group & suffix levels]]
    - [[#using-the-levels-ui][Using the Levels UI]]
- [[#advanced][Advanced]]
  - [[#dynamically-generating-layouts][Dynamically generating layouts]]
  - [[#using-prefix-scope-in-children][Using prefix scope in children]]
    - [[#consuming-scope-to-initialize-a-child][Consuming scope to initialize a child]]
    - [[#obtaining-a-valid-scope-if-prefix-was-not-set-with-it][Obtaining a valid scope if prefix was not set with it]]
  - [[#custom-infix-types][Custom Infix Types]]
- [[#appendixes][Appendixes]]
  - [[#eieio---oop-in-elisp][EIEIO - OOP in Elisp]]
    - [[#transients-defclasss-and-their-inheritance][Transient's defclass's and their inheritance]]
    - [[#view-class-methods-and-attributes][View Class Methods and Attributes]]
  - [[#debugging][Debugging]]
    - [[#print-debug-messages][Print debug messages]]
    - [[#watching-evaluation-in-edebug][Watching evaluation in Edebug]]
  - [[#layout-hacking][Layout Hacking]]
  - [[#hooks][Hooks]]
  - [[#preludes][Preludes]]
    - [[#ts-suffix-wave-command][ts-suffix-wave Command]]
    - [[#ts-suffix-show-level][ts-suffix-show-level]]
    - [[#ts--define-waver][ts--define-waver]]
    - [[#ts-suffix-print-args][ts-suffix-print-args]]
- [[#further-reading][Further Reading]]
:END:

* Terminology

  Transient means temporary.  Transient gets it's name from the temporary keymap
  and the popup UI for displaying that keymap.  Emacs has a similar idea
  built-in with [[elisp:(describe-function 'set-transient-map)][set-transient-map]] for a temporary high-precedence keymap.

** Prefixes and Suffixes

   The hello transient user input sequence is:

  =Prefix -> Suffix=

  - The *prefix* is the command you invoke first, such as =magit-dispatch=
  - A *suffix* is a command displayed in the transient UI, such as
    =magit-stage=

    #+begin_src elisp :tangle no
      (magit-dispatch) ; same as pressing 'h' in magit-status buffer
    #+end_src

  The keymap and UI display is frequently referred to as "a transient".
  "Prefix" and "a transient" are almost the same thing.  Invoking a prefix will
  show a transient.  They are inseparable ideas.

*** Conceptual similarity to Emacs prefix arguments

    *Setting [[https://emacsdocs.org/docs/emacs/Prefix-Keymaps][prefix arguments]] with =universal-argument= (=C-u=) is a distinct, separate
    behavior that is part of Emacs.*

    With prefix arguments, you "call" commands with extra arguments, like you
    would a function.

    A transient prefix can set some states and its suffix can then use these
    states to tweak its behavior.  The difference is that within the lifecycle
    of a transient UI, and coordinating with transient's state persistence, you
    can create much more complex input to your commands.  You can use commands
    to construct phrases for other commands.

    To see a short example of prefix arguments being used within a transient
    prefix, see [[*Scope][the scope example]].
    

** Nesting Prefixes

  A prefix can also be bound as a suffix, enabling /nested/ prefixes.  A user
  input sequence with nested transients might look like:

  =Prefix -> Sub-Prefix -> Sub-Prefix -> Suffix=

  For example, in the =magit-dispatch= transient (=?=), =l= for =magit-log= is
  a nested transient. =b= for =all branches= is the suffix command
  =magit-log-all-branches=.

  See [[*Flow Control][Flow Control]] for nested transient examples with both sub-prefixes and
  suffixes that do no exit.

** Infix

  Some suffixes need to hold state, toggling or storing an argument.  Infixes
  are specialized suffixes to set and hold state.  A user input sequence with
  infixes:

  =Prefix -> Infix -> Infix -> Suffix=

  See [[*Infix.-.Setting.Up.Arguments][Infix examples]] to get a better idea.
  
** Summary

  - *Prefixes* display the pop-up UI and bind the keymap.
  - *Suffixes* are commands bound within a prefix
  - *Infixes* are a specialized suffix for storing and setting state
  - A *Suffix* may be yet another *Prefix*, in which case the transient is
    nested

* Declaring - Equivalent Forms

  You can declare the same behavior 3-4 ways

  - Shorthand forms within =transient-define-prefix= macro allow shorthand binding
    of suffixes & commands or creation of infixes directly within the layout
    definition.

  - Macros for suffixes and infix definition streamline defining commands while
    also defining how they will behave in a layout.

  - Keyword arguments ~(:foo val1 :bar val2)~ are interpreted by the macros and
    used to set slots (OOP attributes) on prefix, group, and suffix objects.  Similar
    forms for declaring suffixes can be used to modify them when declaring a
    layout.  Very specific control over layouts also uses these forms.

    #+begin_src elisp :tangle no
      ;; slots that can be set in children in layouts
      (describe-function transient-child)
    #+end_src

  - Custom classes using EIEIO (basically elisp OOP) can change methods deeper
    in the implementation than you can reach with slots.  =describe-function= is
    a quick way to look at the methods.

    #+begin_src elisp :tangle no
      ;; slots & methods that can be overridden in suffixes
      (describe-function transient-suffix)
    #+end_src

    See the [[*EIEIO - OOP in Elisp][EIEIO Appendix]] for introduction to exploring EIEIO objects and
    classes.

** The Shorthand form

   Binding suffixes with the =("key" "description" suffix-or-command)= form
   within a group is extremely common.
   
   #+begin_src elisp :tangle no :var _=wave-prelude

     (transient-define-prefix ts-wave ()
       "Wave at the user"
       [("w" "wave" ts-suffix-wave)]) ; ts-suffix-wave is a simple command from wave-prelude

     ;; (ts-wave)

   #+end_src

   *Note:* Both commands and suffixes from =transient-define-suffix= can be
   used.  It's a good reason to use =private--namespace= style names for suffix
   actions since these commands don't usually show up in (*M-x*) by default.

** Keyword Arguments Style

   You can customize the slot value (OOP attribute) of the transient, groups,
   and suffixes by adding extra ~:foo value~ style pairs.  
   
   Not all behaviors have a shorthand form, so as you use more behaviors, you
   will see more of the keyword argument style API.  Here we use the
   =:transient= property, set to true, meaning the suffix won't exit the
   transient.

   #+begin_src elisp :tangle no :var _=wave-prelude
     
     (transient-define-prefix ts-wave-keyword-args ()
       "Wave at the user"
       [("w" "wave" ts-suffix-wave :transient t)])

     ;; (ts-wave-keyword-args)

   #+end_src

   Launch the command, wave several times (note timestamp update) and then exit
   with (*C-g*).

** Macro Child Definition Style

   The =transient-define-suffix= macro can help if you need to bind a command in
   multiple places and only override some properties for some prefixes.  It
   makes the prefix definition more compact at the expense of a more verbose
   command.

   #+name ts-wave-suffix-def
   #+begin_src elisp :tangle yes
     
     (transient-define-suffix ts-suffix-wave-suffix ()
       "Macro-defined suffix that waves."
       :transient t
       :key "wm"
       :description "wave from macro definition"
       (interactive)
       (message "Waves from a macro definition at: %s" (current-time-string)))

   #+end_src
   
   #+begin_src elisp :tangle yes :var _=ts-wave-suffix-def
     ;; ts-suffix-wave-suffix defined above

     (transient-define-prefix ts-wave-macro-defined ()
       "Wave using a macro-defined suffix"
       [(ts-suffix-wave-suffix)]) ; note, information moved from prefix to the suffix.

     ;; (ts-wave-macro-defined)

   #+end_src

** Overriding in the prefix definition

   Even if you define a property via one of the macros, you can still override
   that property in the later prefix definition.  The example below overrides
   the =:transient=, =:description=, and =:key= properties of the
   =ts-suffix-wave= suffix defined above:

   #+begin_src elisp :tangle yes :var _=ts-wave-suffix-def

     (defun ts--wave-everride ()
       "Vanilla command used to override suffix's commands."
       (interactive)
       (message "This suffix was overridden.  I am what remains."))

     (transient-define-prefix ts-wave-overriden ()
       "Wave with overriden suffix behavior"
       [(ts--wave-suffix
         :transient nil
         :key "wo"
         :description "wave overridingly"
         :command ts--wave-override)]) ; we overrode what the suffix even does

     ;; (ts-wave-overridden)
     
   #+end_src

   If you just list the key and symbol followed by properties, it is also
   a supported shorthand suffix form:

   =("wf" ts-suffix-wave :description "wave furiously")=

** Quoting Note for Vectors

   Inside the =[ ...vectors... ]= in =transient-define-prefix=, you don't need
   to quote symbols because in the vector, everything is a literal.  When you
   move a shorthand style =:property symbol= out to the
   =transient-define-suffix= form, which is a list, you might need to quote the
   symbol as =:property 'symbol=.
 
* Groups & Layouts

   To define a transient, you need at least one group.  Groups are
   vectors, delimited as =[ ...group... ]=.

   There is basic layout support and you can use it to collect or differentiate
   commands.

   If you begin a group vector with a string, you get a group heading.  Groups
   also support some [[https://magit.vc/manual/transient/Group-Specifications.html#Group-Specifications][properties]].  The [[elisp:(describe-function transient-group)][group class]] also has a lot of information.
** Layouts

   The default behavior treats groups a little differently depending on how they
   are nested.  For most simple groupings, this is sufficient control.

*** Groups one on top of the other

    Use a vector for each row.

   #+begin_src elisp :tangle yes :var _=wave-prelude        

     (transient-define-prefix ts-layout-stacked ()
       "Prefix with layout that stacks groups on top of each other."
       ["Top Group" ("wt" "wave top" ts-suffix-wave)]
       ["Bottom Group" ("wb" "wave bottom" ts-suffix-wave)])

     ;; (ts-layout-stacked)
   #+end_src

*** Groups side by side

    Use a vector of vectors for columns.

   #+begin_src elisp :tangle yes :var _=wave-prelude             
     (transient-define-prefix ts-layout-columns ()
       "Prefix with side-by-side layout."
       [["Left Group" ("wl" "wave left" ts-suffix-wave)]
        ["Right Group" ("wr" "wave right" ts-suffix-wave)]])

     ;; (ts-layout-columns)
   #+end_src

*** Group on top of groups side by side

    Vector on top of vector inside a vector.

   #+begin_src elisp :tangle yes :var _=wave-prelude                  

     (transient-define-prefix ts-layout-stacked-columns ()
       "Wave at the user"
       ["Top Group"
        ("wt" "wave top" ts-suffix-wave)]

       [["Left Group"
         ("wl" "wave left" ts-suffix-wave)]
        ["Right Group"
         ("wr" "wave right" ts-suffix-wave)]])

     ;; (ts-layout-stacked-columns)
   #+end_src

   *Note: Groups can have groups or suffixes, but not both.  You can't mix
   suffixes alongside groups in the same vector.  The resulting transient will
   error when invoked.*

*** Empty strings make spaces

    Groups that are empty or only space have no effect.  This situation can
    happen with layouts that update dynamically.  See [[*dynamic layouts][dynamic layouts]].

   #+begin_src elisp :tangle yes :var _=wave-prelude                  

     (transient-define-prefix ts-layout-spaced-out ()
       "Prefix with side-by-side layout."
       ["" ; cannot add another empty string because it will mix suffixes with groups
        ["Left Group"
         ""
         ("wl" "wave left" ts-suffix-wave)
         ("L" "wave lefter" ts-suffix-wave)
         ""
         ("bl" "wave bottom-left" ts-suffix-wave)]

        [[]] ; empty vector will do nothing

        [""] ; vector with just empty line has no effect
        
        ["Right Group"
         ""
         ("wr" "wave right" ts-suffix-wave)
         ("R" "wave righter" ts-suffix-wave)
         ""
         ("br" "wave bottom-right" ts-suffix-wave)]])

     ;; (ts-layout-spaced-out)
   #+end_src

** Manually setting group class

   If you need to override the class that the =transient-define-prefix= macro
   would normally use.

   #+begin_src elisp :tangle yes :var _=wave-prelude             

     (transient-define-prefix ts-layout-explicit-classes ()
       "Prefix with group class used to explicitly specify layout ."
       [:class transient-row "Row"
               ("l" "wave left" ts-suffix-wave)
               ("r" "wave right" ts-suffix-wave)]
       [:class transient-column "Column"
               ("t" "wave top" ts-suffix-wave)
               ("b" "wave bottom" ts-suffix-wave)])

     ;; (ts-layout-explicit-classes)

   #+end_src

** Descriptions

   Very straightforward.  Just make the first element in the vector a string or
   add a =:description= property, which can be a function.

   In the prefix definition of suffixes, the second string is a description.

   The =:description= key is applied last and therefore wins in ambiguous
   declarations.

   #+begin_src elisp :tangle yes :var _=wave-prelude                       

     (transient-define-prefix ts-wave-descriptively ()
       "Wave at the user"
       [["Group One"
         ("wo" "wave once" ts-suffix-wave)
         ("wa" "wave again" ts-suffix-wave)]

        ["Group Two"
         ("ws" "wave some" ts-suffix-wave)
         ("wb" "wave better" ts-suffix-wave)]]

       ["Bad title" :description "Group of Groups"
        ["Group Three"
         ("k" "bad desc" ts-suffix-wave :description "key-value wins")
         ("n" ts-suffix-wave :description "no desc necessary")]
        [:description "Key Only Def"
         ("wt" "wave too much" ts-suffix-wave)
         ("we" "wave excessively" ts-suffix-wave)]])

     ;; (ts-wave-descriptively)
   #+end_src

*** Dynamic Descriptions

   *Note:* The property list style for dynamic descriptions is the same for both
   prefixes and suffixes.  Add =:description symbol-or-lambda-form= to the group
   vector or suffix list.

   #+begin_src elisp :tangle yes :var _=wave-prelude                            

      (transient-define-prefix ts-wave-dynamic-labels ()
        "Generate labels dynamically when transient is shown."
        ;; group using function-name to generate description
        [:description current-time-string
         ;; single suffix with dynamic description      
         ("wa" ts-suffix-wave
          :description (lambda ()
                         (format "Wave at %s" (current-time-string))))]
        ;; group with anonymoous function generating description
        [:description (lambda ()
                        (format "Group %s" (org-id-new)))
                      ("wu" "wave uniquely" ts-suffix-wave)])

     ;; (ts-wave-dynamic-labels)
   #+end_src

* Nesting & Flow Control

  Many transients call other transients.  This allows you to express similar
  behaviors as interactive commands that ask you for multiple arguments using
  the minibuffer.

  Transient has more options for retaining some state across several transients,
  making it easier to compose commands and to retain intermediate states for
  rapidly achieving series of actions over similar inputs.

** Single versus multiple commands

   Sometimes you want to execute multiple commands without re-opening the
   transient.  It's the same idea as [[https://github.com/emacsorphanage/god-mode][god mode]] or Evil repeat.

   #+begin_src elisp :tangle yes :var _=wave-prelude

     (transient-define-prefix ts-stay-transient ()
       "Some suffixes do not exit."
       ["Exit or Not?"
        ("we" "wave & exit" ts-wave)
        ("ws" "wave & stay" ts-wave :transient t)]) ; this suffix will not exit

     ;; (ts-stay-transient)
   #+end_src

** Nesting

   Nesting is putting transients inside other transients, creating user-input
   sequences like:

   =Prefix -> Sub-Prefix -> Suffix=

*** Binding a Sub-Prefix

    This is the most simple way to create nesting.

    #+name: simple-parent-child
    #+begin_src elisp :tangle yes :var _=wave-prelude

      (transient-define-prefix ts-simple-child ()
        ["Simple Child"
         ("wc" "wave childishly" ts-suffix-wave)])

      (transient-define-prefix ts-simple-parent ()
        ["Simple Parent"
         ("w" "wave parentally" ts-suffix-wave)
         ("c" "become child" ts-simple-child)])

      ;; (ts-simple-child)
      ;; (ts-simple-parent)

    #+end_src

**** Nesting with multiple commands

     Declaring a nested prefix that "returns" to its parent has a convenient
     shorthand form.

    #+begin_src elisp :tangle yes :var _=wave-prelude __=simple-parent-child

      (transient-define-prefix ts-simple-parent-with-return ()
        ["Simple Parent"
         ("w" "wave parentally" ts-suffix-wave)
         ("r" "become child & return" ts-simple-child :transient t)])

      ;; Child does not "return" when called independently
      ;; (ts-simple-child)
      ;; (ts-simple-parent-with-return)

    #+end_src
     
*** Setting up another transient manually

    If you call =(transient-setup 'transient-command-symbol)=, you will activate
    a replacement transient.

    This form is useful if you want a command to /perhaps/ load a transient in
    some situation.  The [[*Scope][scope]] example is helpful if you need to give an
    argument to the transient you are calling into.

    *Note*, the pre-command explanation is critical reading for designing your
    own setup calls.

    #+begin_src elisp :tangle yes :var _=simple-parent-child __=wave-prelude

      (transient-define-suffix ts-suffix-setup-child ()
        "A suffix that uses `transient-setup' to manually load another transient."
        (interactive)
        ;; note that it's usually during the post-command side of calling the
        ;; command that the actual work to set up the transient will occur.
        ;; This is an implementation detail because it depends if we are calling
        ;; `transient-setup' while already transient or not.
        (transient-setup 'ts-simple-child))

      (transient-define-prefix ts-parent-with-setup-suffix ()
        ["Simple Parent"
         ("wp" "wave parentally" ts-suffix-wave :transient t) ; remain transient

         ;; You may need to specify a different pre-command (the :transient) key
         ;; because we need to clean up this transient or create some conditions
         ;; to trigger the following transient correctly.  This exmample will
         ;; work with `transient--do-replace' or no custom pre-command
         
         ("bc" "become child" ts-suffix-setup-child :transient transient--do-replace)])

      ;; (ts-simple-with-setup-suffix)

    #+end_src    

**** Errata

     This example should also work with the =transient--do-recurse= pre-command,
     but the child transient does not return.  There is a difference in the
     behavior that should not depend on if the suffix /is/ the prefix or just sets
     up the prefix.  *Possible bug*.

** Mixing Interactive

   You can mix normal Emacs completion flows with transient UI's.

   See [[elisp:(elisp-index-search "interactive codes")][Interactive codes]] are listed in the Elisp manual.

   *Note*, this also works when binding existing commands that recieve user
   input.

   #+begin_src elisp :tangle yes

     (transient-define-suffix ts--suffix-interactive-string (user-input)
       "An interactive suffix that obtains string input from the user."
       (interactive "s")
       (message "You typed: %s" user-input))

     (transient-define-suffix ts--suffix-interactive-buffer-name (buffer-name)
       "An interactive suffix that obtains a buffer name from the user."
       (interactive "b")
       (message "You selected: %s" buffer-name))

     (transient-define-prefix ts-interactive-basic ()
       ["Interactive Command Suffixes"
        ("s" "enter string" ts--suffix-interactive-string)
        ("b" "select buffer" ts-suffix-interactive-buffer-name)])

     ;; (ts-interactive-basic)

   #+end_src    

*** Early completion

    Sometimes you can complete your work without asking the user for more input.
    In the custom body for a prefix, if you decline to call =transient-setup=,
    then the command will just exit with no problems.

    Below is a nested transient.

    - The body form of the nested child can complete early without loading a new transient
    - The parent uses =transient--do-recurse= to make it's child "return" to it
    - The "radiations" command in the child explicitly overrides this, using
      =transient--do-exit= so that it /does not/ return to the parent

    #+begin_src elisp :tangle true

      (defvar ts--complex nil "Show verbose menu or not")

      (transient-define-suffix ts--toggle-verbose ()
        :transient t
        :description (lambda () (format "toggle verbose: %s" ts--complex))
        (interactive)
        (setf ts--complex (not ts--complex))
        (message (propertize (concat "Complexity set to: "
                                     (if ts--complex "true" "false"))
                             'face 'success)))

      (transient-define-prefix ts-child ()
        ["Complex Messages"
         ("s" "snow people"
          (lambda () (interactive)
            (message (propertize "snow people! ☃" 'face 'success 'size 24))))
         ("k" "kitty cats"
          (lambda () (interactive)
            (message (propertize "🐈 kitty cats! 🐈" 'face 'success 'size 24))))
         ("r" "radiations"
          (lambda () (interactive)
            (message (propertize "radiation! ☢" 'face 'success 'size 24)))
          ;; radiation is dangerous!
          :transient transient--do-exit)]

        (interactive)
        ;; The command body either sets up the transient or simply returns
        ;; This is the "early completion" we're talking about.
        (if ts--complex
            (transient-setup 'ts-child) 
          (message "Simple and boring!")))

      (transient-define-prefix ts-parent ()
        [["Send Message"
          ;; using `transient--do-recurse' causes suffixes in ts-child to perform
          ;; `transient--do-return' so that we come back to this transient.
          ("m" "message" ts-child :transient transient--do-recurse)]
         ["Toggle Verbose"
          ("t" ts--toggle-verbose)]])

      ;; (ts-parent)
      ;; does not "return" when called independently
      ;; (ts-child)

   #+end_src


** Pre-Commands Explained

   In few words, the value in the =:transient= slot affects what state the body
   of your command will see and what will happen after your command, during the
   post-command.
   
   The =:transient= slot holds a function called the "pre-command."  Before your
   suffix body forms run, the pre-command is called and creates the conditions
   that your suffix may use to, for example, prepare for reading variables that
   were set on infixes.

   In =transient-define-prefix= and =transient-define-suffix=, the =t= value is
   actually translated to =transient--do-call= or =transient--do-recurse=
   depending on the situation.

   These functions set up some states so that post-command can figure out if it
   needs to exit, save values, or enter another transient, and what else to do
   while entering that new transient.

   The [[https://magit.vc/manual/transient.html#Transient-State][official long manual]] has some more detail.  These examples should prepare
   you to visualize the forms used in those explanations.

*** Warning!

    Some of the trickiest bugs you can introduce will happen when using the
    following variables and functions at varying points in command lifecycles:

    - =transient-current-command=
    - =transient--command=
    - =transient-current-prefix=
    - =transient--prefix=
    - =transient-args=

    During the pre-command and post-command, these can change.  When you are
    overriding the pre-command, you may discover things such as the result of
    =transient-args= changing.  Calling =transient-setup= may update things.
    Even if you call =transient-args= on on the specific transient, the results
    change during the lifecycle and depending on the pre-command.

    *In particular* it seems like layout predicates should use
    =transient--prefix= while suffix bodies should use
    =transient-current-prefix=. Be aware that the lifecycle is dynamic.

    Not all pre-commands are compatible with all situations and suffixes!

    [[Debugging][Debugging]]

    READ THIS OR YOU MAY LOSE YOUR MIND!
   
* Using & Managing States

  There are several ways to create state.  The [[*Nesting & Flow Control][flow control]] examples in the
  previous section mainly covered how to get from one command to the other.
  This section covers how to save values and then read them later, sometimes
  from a completely different transient.  *Coupled with [[*Custom Infix
  Types][custom infix types]], you can create some seriously rich user
  expression.*

  To spark your imagination, here's a non-exhaustive list of how to get data
  into your commands:

  - Interactive forms
  - Prefix arguments (=C-u= universal argument)
  - Setting the scope in =transient-setup=
  - Obtaining a scope in a custom =initialize-scope= method
  - Default values in prefix definition
  - Saved values of infixes
  - Saved values in other infixes / prefixs with shared =history-key=
  - User-set infix values from the current or parent prefix
  - Ad-hoc values in regular =defvar= and =defcustom= etc
  - Reading values from another, perhaps distant prefix
  - Arguments passed into interactive commands to call them as normal elisp functions

  Using all of these mechanisms, you can enable users to rapidly construct
  complex command sentences, sentences with phrases.  You can basically make a
  user interface as expressive as elisp.

  A user input sequence like this:

  =Prefix -> Sub-Prefix -> Infix -> Sub-Prefix -> Suffix -> Suffix -> ...=

  Is basically the same as doing this in elisp:

  #+begin_src elisp :tangle no

    (function
     (let ((state (function (function argument))))
       (suffix state)
       (suffix state)))

  #+end_src

  This is what is meant by "creating user interfaces as expressive as elisp."
    
** Infixes

   Functions need arguments.  Infixes are specialized suffixes with behavior
   defaults that make sense for setting and storing values for consumption in
   suffixes.  It's like passing arguments into the suffix.  They also have
   support for persisting state across invocations and Emacs sessions.

*** Basic Infixes

    Infix classes built-in all descend from =transient-infix= and can be seen
    clearly in the =eieio-class-browser=.  View their slots and documentaiton
    with ~(describe-class transient-infix)~ etc.  Here you can see what most
    infixes look like and how they behave.

   #+begin_src elisp :tangle yes :var  _=print-args-prelude

     ;; infix defined with a macro
     (transient-define-argument ts--exclusive-switches ()
       "This is a specialized infix for only selecting one of several values."
       :class 'transient-switches
       :argument-format "--%s-snowcone"
       :argument-regexp "\\(--\\(grape\\|orange\\|cherry\\|lime\\)-snowcone\\)"
       :choices '("grape" "orange" "cherry" "lime"))

     (transient-define-prefix ts-basic-infixes ()
       "This transient just shows off many typical infix types."
       ["Infixes"

        ;; from macro
        ("-e" "exclusive switches" ts--exclusive-switches)

        ;; shorthand definitions
        ("-b" "switch with shortarg" ("-w" "--switch-short")) ; with :short-arg != :key
        ("-s" "switch" "--switch")
        ("-a" "argument" "--argument=" :prompt "Let's argue because: ")

        ;; a bit of inline EIEIO in our shorthand
        ("-n" "never empty" "--non-null=" :always-read t
         :init-value (lambda (obj) (oset obj value "better-than-nothing")))

        ("-c" "choices" "--choice=" :choices (foo bar baz))]

       ["Show Args"
        ("s" "show arguments" ts-suffix-print-args)])

     ;; (ts-basic-infixes)
   #+end_src

*** Reading Infix Values   

   *Reminder* in the section on [[*Pre-Commands Explained][pre-commands]] the discussion about the
    =:transient= mentions that the values available in a suffix body depend on
    whe ther the pre-command called =transient--export= before evaluating the
    suffix body.

    There are two basic ways to read infixes:

    - =(transient-
    
** Scope

   When you call a function with an argument, you want to know in the body of
   your function what that argument was.  This is the scope.  The prefix is
   initialized with the =:scope= either in it's own body or a similar form.
   Suffixes can then read back that scope in their body.  The suffix object is
   given the scope and can use it to alter its own display or behavior.  The
   layout also can interpret the scope while it is initializing.

   *WARNING* When writing predicates against the scope, you will need to
   determine whether =transient--prefix= or =transient-current-prefix= is
   correct when writing prefix-generic suffixes.  It is very subtle if you
   accidentally choose the wrong one and the parent has a nil scope while the
   child has an entirely different scope.  These variables change throughout the
   lifecycle!  Use [[*Watching evaluation in Edebug][edebug]] you must!

   #+begin_src elisp :tangle yes

     (transient-define-suffix ts--read-prefix-scope ()
       "Read the scope of the prefix."
       :transient 'transient--do-call
       (interactive)
       (let ((scope (oref transient-current-prefix scope)))
         (message "scope: %s" scope)))

     (transient-define-suffix ts--double-scope-re-enter ()
       "Re-enter the current prefix with double the scope."
       ;; :transient 'transient--do-replace ; builds up the stack       
       :transient 'transient--do-exit
       (interactive)
       (let ((scope (oref transient-current-prefix scope)))
         (if (numberp scope)
             (transient-setup transient-current-command nil nil :scope (* scope 2))
           (message (propertize (format "scope was non-numeric! %s" scope) 'face 'warning))
           (transient-setup transient-current-command))))

     (transient-define-suffix ts--update-scope-with-prefix-re-enter (new-scope)
       "Re-enter the prefix with double the scope."
       ;; :transient 'transient--do-replace ; builds up the stack
       :transient 'transient--do-exit ; do not build up the stack
       (interactive "P")
       (message "universal arg: %s" new-scope)
       (transient-setup transient-current-command nil nil :scope new-scope))

     (transient-define-prefix ts-scope (scope)
       "Message with the object at a location"

       ;; note!  this is a location where we definitely had to use
       ;; `transient--prefix' or get the transient object from the ts-scope symbol.
       ;; `transient-current-prefix' is not correct here!
       [:description (lambda () (format "Scope: %s" (oref transient--prefix scope)))
        [("r" "read scope" ts--read-prefix-scope)
         ("d" "double scope" ts--double-scope-re-enter)
         ("o" "update scope (use prefix argument)" ts--update-scope-with-prefix-re-enter)]]
       (interactive "P")
       (transient-setup 'ts-scope nil nil :scope scope))

     ;; Setting an interactive argument for `eval-last-sexp' is a little different
     ;; (let ((current-prefix-arg 4)) (call-interactively 'ts-scope))

     ;; (ts-scope)
     ;; Then press "C-u 4 o" to update the scope
     ;; Then d to double
     ;; Then r to read
     ;; ... and so on
   #+end_src

*** TODO Errata with prefix arg (=C-u= universal argument).

    Key binding sequences, such as "wa" instead of single-key prefix bindings
    will unset the prefix argument (the old-school Emacs =C-u= prefix argument,
    not the prefix's scope or other explicit arguments)

    *Possibly a bug in transient.*

** Prefix Value & History

  Each transient has a =:value=.  We can get this as a list of strings for any
  prefix by calling =transient-args= on =transient-current-command= in the
  suffix's interactive form.  If you know the command you want the value of, you
  can use it's symbol instead of =transient-current-command=.

  This is related to history keys.  If you set the arguments and then save them
  using (=C-s=) for the command =transient-save=, not only will the transient be
  updated with the new value, but if you call the child independently, it can
  still read

  #+begin_src elisp :tangle yes :var _=print-args-prelude

    (transient-define-suffix ts-suffix-eat-snowcone (args)
      "Eat the snowcone!
    This command can be called from it's parent, `ts-snowcone-eater' or independently."
      :transient t
      ;; you can use the interactive form of a command to obtain a default value
      ;; from the user etc if the one obtained from the parent is invalid.
      (interactive (list (transient-args 'ts-snowcone-eater)))

      ;; `transient-arg-value' can (with varying success) pick out individual
      ;; values from the results of `transient-args'.

      (let ((topping (transient-arg-value "--topping=" args))
            (flavor (transient-arg-value "--flavor=" args)))
        (message "I ate a %s flavored snowcone with %s on top!" flavor topping)))

    (transient-define-prefix ts-snowcone-eater ()
      "Eat a flavored snowcone!"

      ;; This prefix has a default value that ts-suffix-eat-snowcone can see
      ;; even before the prefix has been called.
      :value '("--topping=fruit" "--flavor=cherry")

      ;; always-read is used below so that you don't save nil values to history
      ["Arguments"
       ("-t" "topping" "--topping="
        :choices ("ice cream" "fruit" "whipped cream" "mochi")
        :always-read t)
       ("-f" "flavor" "--flavor="
        :choices ("grape" "orange" "cherry" "lime")
        :always-read t)
       ("S" "save snowcone settings"
        (lambda ()
          (interactive)
          (message "saved!")
          (transient-save))
        :transient t)]

      ["Actions"
       ("m" "message arguments" ts-suffix-print-args)
       ("e" "eat snowcone" ts-suffix-eat-snowcone)])

    ;; First call will use the transient's default value
    ;; (ts-suffix-eat-snowcone)
    ;; (ts-snowcone-eater)    
    ;; Eat some snowcones with different flavors
    ;; ...
    ;; ...
    ;; ...
    ;; Now save the value and exit the transient.
    ;; When you call the suffix independently, it can still read the saved values!
    ;; (ts-suffix-eat-snowcone)

  #+end_src

* Controlling CLI's

  This section covers more usages of infixes, focused on creating better
  argument strings for CLI tools.

  The section on [[*Flow control & managing state][flow control & managing state]] has more information about
  controlling elisp applications.

** Reading arguments within suffixes

   *Note:* these forms are generic for different prefixes, allowing you to mix
   and match suffixes within prefixes.

** Switches & Arguments

   The shorthand forms in =transient-define-prefix= are heavily influenced by
   the CLI style switches and arguments that transient was built to
   control. Most shorthand forms look like so:

   =("key" "description" "argument")=

   The macro will select the infix's exact class depending on how you write
   =:argument=.  If you write something ending in ~=~ such as ~--value=~ then
   you get =:class transient-option= but if not, the default is a =:class
   transient-switch=

   Use [[elisp:(describe-function transient-option)][=(describe-function transient-option)=]] and [[elisp:(describe-function transient-switch)][=(describe-function transient-option)=]]
   to see a full document of their slots and methods.

   If you need an argument with a space instead of the equal sign, use a space
   and force the infix to be an argument by setting =:class transient-option=.

   #+begin_src elisp :tangle yes :var _=print-args-prelude
     (transient-define-prefix ts-switches-and-arguments (arg)
       "Wave at the user"
       [["Arguments"
         ("-s" "switch" "--switch")
         ("-a" "argument" "--argument=")
         ("t" "toggle" "--toggle")
         ("v" "value" "--value=")]

        ["More Arguments" 
         ("-f" "argument with forced class" "--forced-class " :class transient-option)
         ("I" "argument with inline" ("-i" "--inline-shortarg="))
         ("S" "inline shortarg switch" ("-n" "--inline-shortarg-switch"))]]

       ["Commands"
        ("w" "wave some" ts-wave)
        ("s" "show arguments" ts-suffix-print-args)]) ; use to analyze the switch values

     ;; (ts-switches-and-arguments)
   #+end_src

*** Default Values

    Every transient prefix has a value.  It's a list.  You can set it to create
    defaults for switches and arguments.

   #+begin_src elisp
     (transient-define-prefix ts-wave ()
       "Wave at the user"

       :value '("--toggle" "--value=default")

       ["Arguments"
        ("-s" "switch" "--switch")
        ("-a" "argument" "--argument=")
        ("t" "toggle" "--toggle")
        ("v" "value" "--value=" :prompt "\"default\" or an integer: ")]

       ["Commands"
        ("ws" "wave some" ts-suffix-wave)
        ("wb" "wave better" ts-suffix-wave)])

     ;; (ts-wave)
   #+end_src

*** Argument and Switch Macros

   If you need to fine-tune a switch, use =transient-define-infix=.  Likewise,
   use =transient-define-argument= for fine-tuning an argument.  The class
   definitions can be used as a reference while the [[https://magit.vc/manual/transient/Suffix-Slots.html#Slots-of-transient_002dinfix][manual]] provides more
   explanation.

   #+begin_src elisp :tangle yes :var _=reporter_prelude

     (transient-define-infix ts--random-init-infix ()
       "Switch on and off"
       :argument "--switch"
       :shortarg "-s" ; will be used for :key when key is not set
       :description "switch"
       ; if you haven't seen setf, think of it as having the power to set via a getter
       :init-value (lambda (ob)
                     (setf
                      (slot-value ob 'value) ; get value
                      (eq 0 (random 2))))) ; write t with 50% probability

     (transient-define-prefix ts-maybe-on ()
       "A randomly intializing switch."
       ["Arguments"
        (ts--random-init-infix)]
       ["Show Args"
        ("s" "show arguments" ts-suffix-print-args)])

     ;; (ts-maybe-on)
     
   #+end_src

*** Choices

   Choices can be set for an argument.  The property API and
   =transient-define-argument= are equivalent for configuring choices.  You can
   either hardcode or generate choices.

   #+begin_src elisp :tangle yes :var _=print-args-prelude

     (transient-define-argument ts--animals-argument ()
       "Animal picker"
       :argument "--animals="
       ; :multi-value t ; multi-value can be set to --animals=fox,otter,kitten etc
       :class 'transient-option
       :choices '("fox" "kitten" "peregrine" "otter"))

     (transient-define-prefix ts-animal-choices ()
       "Select animal"
       ["Arguments"
        ("-a" "--animals=" ts--animals-argument)
       ["Show Args"
        ("s" "show arguments" ts-suffix-print-args)])

     ;; (ts-animal-choices)

   #+end_src

**** Choices shorthand in prefix definition

   Choices can also be defined in a shorthand form.  Use =:class
   'transient-option= if you need to force a different class to be used.

   #+begin_src elisp :tangle no :var _=print-args-prelude

     (transient-define-prefix ts-animal-choices-shorthand ()
       "Select animals from choices"
       ["Arguments"
        ("-a" "Animal" "--animal=" :choices ("fox" "kitten" "peregrine" "otter"))]
       ["Show Args"
        ("s" "show arguments" ts-suffix-print-args)])

     ;; (ts-animal-choices-shorthand)
     
   #+end_src

*** Mutually Exclusive Switches

   An argument with =:class transient-switches= may be used if a set of
   switches is exclusive.  The key will likely /not/ match the short argument.
   Regex is used to tell the interface that you are entering one of the
   choices.  The selected choice will be inserted into =:argument-format=.  The
   =:argument-regexp= must be able to match any of the valid options.

   *The UX on mutually exclusive switches is a bit of a pain to discover.  You
   must repeatedly press =:key= in order to cycle through the options.*

   #+begin_src elisp :tangle yes :var  _=print-args-prelude

     (transient-define-argument ts--snowcone-flavor ()
       :description "Flavor of snowcone"
       :class 'transient-switches
       :key "f"
       :argument-format "--%s-snowcone"
       :argument-regexp "\\(--\\(grape\\|orange\\|cherry\\|lime\\)-snowcone\\)"
       :choices '("grape" "orange" "cherry" "lime"))

     (transient-define-prefix ts-exclusive-switches ()
       "Eat a flavored snowcone!"
       :value '("--orange-snowcone")

       ["Arguments"
        (ts--snowcone-flavor)]
       ["Show Args"
        ("s" "show arguments" ts-suffix-print-args)])

     ;; (ts-exclusive-switches)
   #+end_src

*** Incompatible Switches

    If you need to prevent arguments in a group from being set simultaneously,
    you can set the prefix property =:incompatible= and a list of the long-style
    argument.

    Use a list of lists, where each sublist is the long argument style. Match
    the string completely, including use of ~=~ in both arguments and switches.

   #+begin_src elisp :tangle yes :var  _=print-args-prelude    

       (transient-define-prefix ts-incompatible ()
         :incompatible '(

                         ;; update your transient version if you experience #129 / #155
                         ("--switch" "--value=")

                         ("--switch" "--toggle" "--flip")
                         ("--argument=" "--value=" "--special-arg="))

         ["Arguments"
          ("-s" "switch" "--switch")
          ("-t" "toggle" "--toggle")
          ("-f" "flip" "--flip")

          ("-a" "argument" "--argument=")
          ("v" "value" "--value=")
          ("C-a" "special arg" "--special-arg=")]
         ["Show Args"
          ("s" "show arguments" ts-suffix-print-args)])

       ;; (ts-incompatible)

   #+end_src

*** TODO Short Args

    *This section is incomplete.  Maybe Magit contains better answers.*

    Sometimes the =:shortarg= in a CLI doesn't exactly match the =:key:= and
    =:argument=, so it can be specified manually.
    
    The =:shortarg= concept could be used to help use man-pages or only for
    [[https://magit.vc/manual/transient.html#index-transient_002ddetect_002dkey_002dconflicts][transient-detect-key-conflicts]] but it's not clear what behavior it changes.
   
    Shortarg cannot be used for exclusion excluding other options (prefix
    =:incompatible=) or setting default values (prefix =:value=).

*** TODO Choices from a function

    *This section is incomplete.  While it runs, it's likely not demonstrating a
    full understanding of completions in Emacs.*

   #+begin_src elisp :tangle no :var  _=print-args-prelude

     (defun ts--animal-choices (complete-me filter-p completion-type)
       ;; complete-me: whatever the user has typed so far
       ;; filter-p: function you should use to filter candidates (only nil seen so far)
       ;; completion-type: t on first input and (metadata . alist) thereafter
       ;;
       ;; Documentation is from Emacs.  This is not transient-specific behavior
       ;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html

       (if (eq 0 (random 2))
           '("fox" "kitten" "otter")
         '("ant" "peregrine" "zebra")))

     (transient-define-prefix ts-choices-with-completions ()
       "Select animal"
       ["Arguments"
        ("-a" "Animal" "--animal="
         :always-read t ; don't allow unsetting, just read a new value
         :choices ts--animal-choices)]
       ["Show Args"
        ("s" "show arguments" ts-suffix-print-args)])

     ;; (ts-choices-with-completions)
   #+end_src

** Dispatching args into a process

   If you want to call a command line application using the arguments, you might
   need to do a bit of work processing the arguments.  The following example
   uses cowsay.

   - Cowsay doesn't actually have a =message== argument, So we end up stripping
     it from the arguments and re-assembling something =call-process= can use.
     
   - Cowsay supports more options, but for the sake of keeping this example
     small (and to refocus effort on transient itself), the set of all CLI
     options are not fully supported.

   There's some errata about this example:

   - The predicates don't update the transient.  =(transient--redisplay)=
     doesn't do the trick.  We could use =transient--do-replace= and
     =transient-setup=, but that would lose existing state
     
   - The predicate needs to be exists & not empty (but doesn't matter yet)

  #+begin_src elisp

    (defun ts--quit-cowsay ()
      "Kill the cowsay buffer and exit"
      (interactive)
      (kill-buffer "*cowsay*"))

    (defun ts--cowsay-buffer-exists-p ()
      (not (equal (get-buffer "*cowsay*") nil)))

    (transient-define-suffix ts--cowsay-clear-buffer (&optional buffer)
      "Delete the *cowsay* buffer.  Optional BUFFER name."
      :transient 'transient--do-call
      :if 'ts--cowsay-buffer-exists-p
      (interactive) ; todo look at "b" interactive code

      (save-excursion
        (let ((buffer (or buffer "*cowsay*")))
          (set-buffer buffer)
          (delete-region 1 (+ 1 (buffer-size))))))

    (transient-define-suffix ts--cowsay (&optional args)
      "Run cowsay"
      (interactive (list (transient-args transient-current-command)))
      (let* ((buffer "*cowsay*")
             ;; TODO ugly
             (cowmsg (if args (transient-arg-value "--message=" args) nil))
             (cowmsg (if cowmsg (list cowmsg) nil))
             (args (if args
                       (seq-filter
                        (lambda (s) (not (string-prefix-p "--message=" s))) args)
                     nil))
             (args (if args
                       (if cowmsg
                           (append args cowmsg)
                         args)
                     cowmsg)))

        (when (ts--cowsay-buffer-exists-p)
          (ts--cowsay-clear-buffer))
        (apply #'call-process "cowsay" nil buffer nil args)
        (switch-to-buffer buffer)))

    (transient-define-prefix ts-cowsay ()
      "Say things with animals!"

      ; only one kind of eyes is meaningful at a time
      :incompatible '(("-b" "-g" "-p" "-s" "-t" "-w" "-y"))

      ["Message"
       ("m" "message" "--message=" :always-read t)] ; always-read, so clear by entering empty string
      [["Built-in Eyes"
        ("b" "borg" "-b")
        ("g" "greedy" "-g")
        ("p" "paranoid" "-p")
        ("s" "stoned" "-s")
        ("t" "tired" "-t")
        ("w" "wired" "-w")
        ("y" "youthful" "-y")]
       ["Actions"
        ("c" "cowsay" ts--cowsay :transient transient--do-call)
        ""
        ("d" "delete buffer" ts--cowsay-clear-buffer)
        ("q" "quit" ts--quit-cowsay)]])

    ;; (ts-cowsay)

  #+end_src
   
** Lisp Variables

   Lisp variables are currently at an experimental support level.  They way they
   work is to report and set the value of a lisp symbol variable.  Because they
   aren't necessarilly intended to be printed as crude CLI arguments, they *DO
   NOT* appear in =(transient-args 'prefix)= but this is fine because you can
   just use the variable.

   Customizing this class can be useful when working with objects and functions
   that exist entirely in elisp.

   #+begin_src elisp :tangle yes :var _=wave-prelude

     (defvar ts--position '(0 0) "A transient prefix location")

       (transient-define-infix ts--pos-infix ()
         "A location, key, or command symbol"
         :class 'transient-lisp-variable
         :transient t
         :prompt "An expression such as (0 0), \"p\", nil, 'ts--msg-pos: "
         :variable 'ts--position)

       (transient-define-suffix ts--msg-pos ()
         "Message the element at location"
         :transient 'transient--do-call
         (interactive) 
         ;; lisp variables are not sent in the usual (transient-args) list.
         ;; Just read `ts--position' directly.
         (let ((suffix (transient-get-suffix transient-current-command ts--position)))
           (message "%s" (oref suffix description))))

       (transient-define-prefix ts-msg-location ()
         "Message with the object at a location"
         ["Location Printing"
          [("p" "position" ts--pos-infix)]
          [("m" "message" ts--msg-pos)]])

       ;; (ts-msg-location)
   #+end_src

* Controlling Visibility

  At times, you need a prefix to show or hide certain options depending on the
  context.

** Predicates

   Simple [[https://magit.vc/manual/transient/Predicate-Slots.html#Predicate-Slots][predicates]] at the group or element level exist to hide parts of the
   transient when they wouldn't be useful at all in the situation.

   #+name: predicates-prelude
   #+begin_src elisp :hidden yes

     (defvar ts-busy nil "Are we busy?")

     (defun ts--busy-p () "Are we busy?" busy)

     (transient-define-suffix ts--toggle-busy ()
       "Toggle busy"
       (interactive)
       (setf busy (not busy))
       (message (propertize (format "busy: %s" busy)
                            'face 'success)))

     #+end_src

   Open the following example in buffers with different modes (or change modes
   manually) to see the different effects of the mode predicates.

     #+begin_src elisp :tangle yes :var _=predicates-prelude

       ;; This block uses the predicates-prelude

       (transient-define-prefix ts-predicates ()
         "Wave at the user"
         ["Empty Groups Not Displayed"
          ;; in org mode for example, this group doesn't appear.
          ("we" "wave elisp" ts-suffix-wave :if-mode emacs-lisp-mode)
          ("wc" "wave in C" ts-suffix-wave :if-mode cc-mode)]

         ["Lists of Modes"
          ("wm" "wave multiply" ts-suffix-wave :if-mode (dired-mode gnus-mode))]

         [["Function Predicates"
           ;; note, after toggling, the transient needs to be re-displayed for the
           ;; predicate to take effect
           ("b" "toggle busy" ts--toggle-busy)
           ("bw" "wave busily" ts-suffix-wave :if ts--busy-p)]

          ["Programming Actions"
           :if-derived prog-mode
           ("pw" "wave programishly" ts-suffix-wave)
           ("pe" "wave in elisp" ts-suffix-wave :if emacs-lisp-mode)]
          ["Special Mode Actions"
           :if-derived special-mode
           ("sw" "wave specially" ts-suffix-wave)
           ("sd" "wave dired" ts-suffix-wave :if-mode dired-mode)]
          ["Text Mode Actions"
           :if-derived text-mode
           ("tw" "wave textually" ts-suffix-wave)
           ("to" "wave org-modeishly" ts-suffix-wave :if-mode org-mode)]])

       ;; (ts-predicates)
   #+end_src

** Inapt (Temporarily Unavailable)

   "Greyed out" suffixes.  Inapt is better if an option is temporarily
   unavailable due to a state that varies with each invocation of the
   transient.

   Inapt predicates work on suffixes, but not on groups (which would have to
   modify every child).

   *Note*, like visibility predicates, =inapt-*= predicates do not take effect
   until the transient has it's layout fully redone.  Therefore this example
   uses a child transient and updates the scope.

   #+begin_src elisp :tangle yes :var _=print-args-prelude :var __=levels-prelude

     (defun ts--child-scope-p ()
       "Returns the scope of the current transient.
     When this is called in layouts, it's the transient being layed out"
       (let ((scope (oref transient--prefix scope)))
         (message "The scope is: %s" scope)
         scope))

     ;; the wave suffixes were :transient t as defined, so we need to manually
     ;; override them to the `transient--do-return' value for :transient slot so
     ;; that they return back to the parent.
     (transient-define-prefix ts--inapt-children ()
       ["Inapt Predicates Child"
        ("s" "switched" ts--wave-surely
         :transient transient--do-return
         :if ts--child-scope-p)
        ("u" "unswitched" ts--wave-normally
         :transient transient--do-return
         :if-not ts--child-scope-p)]

       ;; in the body, we read the value of the parent and set our scope to
       ;; non-nil if the switch is set
       (interactive)
       (let ((scope (transient-arg-value "--switch" (transient-args 'ts-inapt-parent))))
         (message "scope: %s" scope)
         (message "type: %s" (type-of scope))
         (transient-setup 'ts--inapt-children nil nil :scope (if scope t nil))))

     (transient-define-prefix ts-inapt-parent ()
       "Inapt Predicates Parent"

       [("-s" "switch" "--switch")
        ("a" "show arguments" ts-suffix-print-args)
        ("c" "launch child prefix" ts--inapt-children :transient transient--do-recurse)])

     ;; (ts-inapt-parent)
   #+end_src

***  TODO Documentation in manaual missing

    There is not a single mention of inapt even though it's fully implemented
    and works.

** Levels

   Levels are another way to control visibility.

   - As a developer, you set levels to optionally expose or hide children in a
     prefix.
   - As a user, you change the prefix's level and the levels of suffixes to
     customize what's visible in the transient.

   *Lower levels are more visible. Setting the level higher reveals more
   suffixes.*   1-7 are valid levels.

   The user can adjust levels within a transient prefix by using (*C-x l*) for
   =transient-set-level=.  The default active level is 4, stored in
   =transient-default-level=.  The default level for children is 1, stored in
   =transient--default-child-level=.

   Per-suffix and per-group, the user can set the level at which the child will
   be visible.  Each prefix has an active level, remembered per prefix.  If the
   child level is less-than-or-equal to the child level, the child is visible.   

   A hidden group will hide a suffix even if that suffix is at a low enough
   level.  Issue #153 has some addional information about behavior that might
   get cleaned up.

**** Defining group & suffix levels
   
   Adding default levels for children is as simple as adding integers at the
   beginning of each list or vector.  If some commands are not likely to be
   used, instead of making the hard choice to include them or not, you can
   provide them, but tell the user in your README to set higher levels.
     
     #+begin_src elisp :tangle yes :var _=levels-prelude :var _=show-level-suffix
       ;; This block uses levels-prelude

       (transient-define-prefix ts-levels-and-visibility ()
         "Wave at the user with configurable suffix visibility."

         [["Setting the Current Level"
           ;; this binding is normally not displayed.  The value of
           ;; `transient-show-common-commands' controls this by default.
           ("C-x l" "set level" transient-set-level)
           ("s" "show level" ts-suffix-show-level)]

          [2 "Per Group" ; 1 is the default default-child-level
             ("ws" "wave surely" ts--wave-surely) ; 1 is the default default-child-level
             (3"wn" "wave normally" ts--wave-normally)
             (5"wb" "wave non-essentially" ts--wave-non-essentially)]

          [3 "Per Group Somewhat Useful"
             ("wd" "wave definitely" ts--wave-definitely)]

          [6 "Groups hide visible children"
             (1 "wh" "wave hidden" ts--wave-hidden)]

          [5 "Per Group Rarely Useful"
             ("we" "wave eventually" ts--wave-eventually)]])

       ;; (ts-levels-and-visibility)
   #+end_src

**** Using the Levels UI   

   Press (*C-x l*) to open the levels UI for the user.  Press (*C-x l*) again to
   change the active level.  Press a key such as "we" to change the level for a
   child.  After you cancel level editing with (*C-g*), you will see that children
   have either become visible or invisible depending on the changes you made.

   *While a child may be visible according to its own level, if it's hidden
   within the group, the user's level-setting UI for the prefix will contradict
   what's actually visible.  The UI does not allow setting group levels.*   

   
* Advanced

  The previous sections are designed to go breadth-first so that you can get
  core ideas first. The following examples expand on combinations of several
  ideas or subclassing & customizing rarely used slots.

  Some of these examples are approaching the complexity of just reading [[elisp:(find-library "magit")][magit source]].

** Dynamically generating layouts

   While you can cover many cases using predicates, layouts, and visibility,
   *sometimes you really do want to generate a list of commands.*

   *Note*, beware that you could be creating a lot of suffix objects if the
   forms you use generate unique symbols.  These will pollute command
   completions over time, so probably don't do that.

   [[https://magit.vc/manual/transient.html#index-transient_002dsetup_002dchildren][transient-setup-children]]
   
   is a prefix method that can be overriden in order to modify or eliminate some
   children from display.  If you need a central place for children to
   coordinate some behavior, this may work for you.
  
** TODO Using prefix scope in children

*** TODO Consuming scope to initialize a child

*** TODO Obtaining a valid scope if prefix was not set with it

** Custom Infix Types

   If you need to set and display a custom type, use the simple OOP techniques of
   [[*EIEIO][EIEIO]].  =:initform= is a default value.  =:initarg= configures which argument
   to pick up from the class constructor.

   Let's write a transient menu that can interrogate transient prefixes!  We
   need to be able to pick a child from the prefix's layout and then get
   information about its properties and finally to set the properties.

   First we need an infix to pick, store, and display the suffix or group we are
   operating on.

   We will use several new pieces here:

   - =transient-get-suffix= To get suffix by a key, location, or command symbol
   - =transient-format-description= Method works on children to get their
     description string

   #+begin_src elisp :tangle yes

     ;; The children we will be picking can be of several forms.  The
     ;; transient--layout symbol property of a prefix is a vector of vectors, lists,
     ;; and strings.  It's not the actual eieio types or we would use
     ;; `transient-format-description'
     (defun ts--layout-child-desc (layout-child)
       "Get the description from a transient layout vector or list."
       (cond
        ((vectorp layout-child) (or (plist-get (aref layout-child 2) :description) "<group>")) ; group
        ((stringp layout-child) layout-child) ; plain-text child
        ((listp layout-child) (plist-get (elt layout-child 2) :description)) ; suffix
        (t (format "idk: %s" layout-child))))

     ;; Inherit from variable abstract class
     (defclass transient-child-variable (transient-variable)
       ((reader :initform #'transient-child-variable--reader )
        (transient :initform 'transient--do-call))) ; we want access to transient-current-command

     ;; We have to define this on non-abstract infix classes.  See
     ;; `transient-init-value' in transient source.
     (cl-defmethod transient-init-value ((obj transient-child-variable))
       (oset obj value nil))

     (cl-defmethod transient-prompt ((obj transient-child-variable))
       "Location, a key \"a\", 'suffix-command, or coordinates like (0 1): ")

     ;; Customize how we display our value since it's actual value is ugly
     (cl-defmethod transient-format-value ((obj transient-child-variable))
       "All transient children have some description we can display.
     Show either the child's description or a default if no child is selected."
       (let ((value (if (slot-boundp obj 'value) (slot-value obj 'value) nil)))
         (if value
             (propertize
              (format "(%s)" (ts--layout-child-desc value))
              'face 'transient-value)
           (propertize "¯\_(ツ)_/¯" 'face 'transient-inactive-value))))

     ;; We repeat the read using a lisp expression from `read-from-minibuffer' to get
     ;; the LOC key for `transient-get-suffix' until we get a valid result.  This
     ;; ensures we don't store an invalid LOC.
     (defun transient-child-variable--reader (prompt initial-input history)
       "Read a location and check that it exists within the current transient."
       (save-match-data
         (cl-block nil ; allows cl-return
           (while t
             ;; read a string, then read it as a lisp object
             (let* ((loc (read (read-from-minibuffer prompt initial-input nil nil history)))
                    (child (ignore-errors (transient-get-suffix transient-current-command loc))))
               (when child
                 (cl-return child)) ; breaks loop
               (message
                (propertize
                 (format "Location could not be found in prefix %s"
                         transient-current-command) 'face 'error))
               (sit-for 1)))))) ; wait a second

     ;; TODO really wish I don't need explicit infix declation
     (transient-define-infix ts--inception-child ()
       :class transient-child-variable)

     ;; All set!  This transient just tests our or new toy.
     (transient-define-prefix ts-inception-set ()
       "Pick a suffix, any suffix"
       [["Pick"
         ("c" "child" ts--inception-child :class transient-child-variable)]])

     ;; (ts-inception-set)

    #+end_src
   
* Appendixes
  
** EIEIO - OOP in Elisp

    Emacs lisp ships with eieio, a close cousin to the Common Lisp Object
    System.  It's OOP.  There are classes & subclasses.  You can inherit into new
    classes and override methods to customize behaviors.

    You can use eieio API's to explore transient objects.  Let's look at some
    transients you have already:

    #+begin_src elisp :tangle no :results replace

      ;; The plist for a prefix command contains a `transient-prefix' object in the
      ;; `transient--prefix' key and a vector layout in `transient--layout' (symbol-plist
      (symbol-plist 'magit-dispatch)

      ;; getting the values from the symbol plist
      (plist-get (symbol-plist 'magit-dispatch) 'transient--prefix)

      (let ((prefix-object (plist-get (symbol-plist 'magit-dispatch) 'transient--prefix)))

        ;; printing the current slot values for that object
        (object-write prefix-object)

        ;; ;; Object transient-prefix-20997da
        ;; (transient-prefix "transient-prefix-20997da"
        ;;   :command magit-dispatch  :info-manual "(magit)Top")

        ;; getting the class of an object
        (eieio-object-class prefix-object) ; transient-prefix

        ;; opening the help documents for the class, which shows all methods and
        ;; slot forms
        (describe-function transient-prefix))

    #+end_src

*** Transient's defclass's and their inheritance

    Here's a list of all of transient's =defclass= and their ancestry.  This is
    how it is in 2022.

    #+begin_src elisp :tangle no :results replace

      (eieio-class-browser) ; shows all known classes and their ancestry
      
      ;;    +--transient-child
      ;;    |    +--transient-group
      ;;    |    |    +--transient-subgroups
      ;;    |    |    +--transient-columns
      ;;    |    |    +--transient-row
      ;;    |    |    +--transient-column
      ;;    |    +--transient-suffix
      ;;    |         +--transient-infix
      ;;    |              +--transient-variable
      ;;    |              |    +--transient-lisp-variable
      ;;    |              +--transient-argument
      ;;    |                   +--transient-switches
      ;;    |                   +--transient-option
      ;;    |                   |    +--transient-files
      ;;    |                   +--transient-switch
      ;;    +--transient-prefix

    #+end_src

*** View Class Methods and Attributes

    Using =describe-function= is extremely handly for viewing the class slots
    and methods.

    Classes used in transient that you are likely to want to know the slots for:
    
    [[elisp:(describe-function 'transient-prefix)][transient-prefix]]
    [[elisp:(describe-function 'transient-suffix)][transient-suffix]]
    [[elisp:(describe-function 'transient-infix)][transient-infix]]
    [[elisp:(describe-function 'transient-argument)][transient-argument]]

    [[https://www.gnu.org/software/emacs/manual/html_mono/eieio.html#Inheritance][The eieio docs]] have a more wordy treatment.  The class system has a lot of
    behavior that can be faster at times to just understand through description.
    
** Debugging

   There is a lot of support for both print-line and step-through debugging.
   
*** Print debug messages

    Just set =transient--debug= to t.  [[elisp:(setq transient--debug t)][(setq transient-debug t)]]

    You will get a lot of logs visible in =*Messages*= via
    [[elisp:(view-echo-message-area)][view-echo-message-area]] the next time you run a transient.

    #+begin_src text

    -- setup              (cmd: ts-layout-rows-explicit, event: "M-x", exit: nil)
    -- stack-zap          (cmd: ts-layout-rows-explicit, event: "M-x", exit: nil)
    -- init-transient     (cmd: ts-layout-rows-explicit, event: "M-x", exit: nil)
         push transient--transient-map
         push transient--redisplay-map
    -- post-command       (cmd: ts-layout-rows-explicit, event: "M-x", exit: nil)
    Invalid face reference: org-indent [12 times]
    -- pre-command        (cmd: transient-update, event: "w", exit: nil)
         pop  transient--redisplay-map
    -- post-command       (cmd: transient-update, event: "w", exit: nil)
         pop  transient--redisplay-map
         push transient--redisplay-map
    -- pre-command        (cmd: ts-suffix-wave, event: "w l", exit: nil)
    -- stack-zap          (cmd: ts-suffix-wave, event: "w l", exit: nil)
    -- pre-exit           (cmd: ts-suffix-wave, event: "w l", exit: t)
         pop  transient--transient-map
         pop  transient--redisplay-map
    Waves at the user at: Sat Nov 12 22:38:20 2022.
    -- post-command       (cmd: ts-suffix-wave, event: "w l", exit: t)
    -- post-exit          (cmd: ts-suffix-wave, event: "w l", exit: t)
              
    #+end_src

*** Watching evaluation in Edebug

    *Edebug works with transients.  There is much support in transient to
    facilitate using edebug.*

    For watching the flow control around your command, especially helpful for
    debugging behavior around setup, layout, or suffix dispatch, you might want
    to watch your transient in Edebug.

    [[https://www.youtube.com/watch?v=odkYXXYOxpo][Edebug]] basic introduction video (10 min).

    In short:

    - goto your [[elisp:(find-library "transient")][transient source]]
    - instrument a function you want to watch with =edebug-defun=
    - call the transient / suffix that triggers entry of that function
    - use =SPC= to step forward, =c= to continue, =i= to enter a function call,
      or =h= for help etc

    First watch the debug output to gain an idea of how your code flows with the
    transient code.  Then instrument transient behaviors such as
    =transient--post-exit= and use =i= to =edebug-step-in= to calls of interest.

    When you are done, remember to use [[elisp:(edebug-remove-instrumentation)][=edebug-remove-instrumentation=]] so that
    you can go on without every transient you open trying to call the debugger.

** Layout Hacking

    First you need to explort the layout data structures.

    #+begin_src elisp :tangle no :results replace

      ;; Let's look at the layout
      (let ((prefix-layout (plist-get (symbol-plist 'magit-dispatch) 'transient--layout)))

        (type-of prefix-layout) ; cons

        (listp prefix-layout) ; t

        (length prefix-layout) ; 3

        ;; Each group in the list is a vector
        (vectorp (car prefix-layout)) ; t

        (elt (car prefix-layout) 0) ; first element is a priority
        (elt (car prefix-layout) 1) ; second is a type name
        (elt (car prefix-layout) 2) ; contents & attributes

        ;; the attributes are key-value pairs used to create the class
        ;; instance when the transient is shown.

        ;; the nested contents will be lists of vectors for groups and
        ;; lists of lists for suffixes.

        )

      ;; A sample layout

      ;; ([1 transient-column nil
      ;;     ((1 transient-suffix
      ;;         (:key "i" :description "Ignore" :command magit-gitignore))
      ;;      (1 transient-suffix
      ;;         (:key "I" :description "Init" :command magit-init))
      ;;      (1 transient-suffix
      ;;         (:key "j" :description "Jump to section" :command magit-status-jump :if-mode magit-status-mode))
      ;;      (1 transient-suffix
      ;;         (:key "j" :description "Display status" :command magit-status-quick :if-not-mode magit-status-mode)))])

    #+end_src

    You might find this helpful when constructing [[*Dynamic Layouts][dynamic layouts]]

** Hooks

   Just a reminder, some hooks exist.  Use =describe-variable= and complete with
   =transient hook= for the most recent list of hooks.

** Preludes

   Definitions that are not that interesting on their own but are used in examples.

*** ts-suffix-wave Command
   
   #+name: wave-prelude
   #+begin_src elisp :tangle yes

     (defun ts-suffix-wave ()
       "Wave at the user"
       (interactive)
       (message "Waves at the user at: %s." (current-time-string)))

   #+end_src

*** ts-suffix-show-level

   #+name: show-level-suffix    
   #+begin_src elisp

     (transient-define-suffix ts-suffix-show-level ()
       "Show the current transient's level."
       :transient t
       (interactive)
       (message "Current level: %s" (oref transient-current-prefix level)))    

   #+end_src
    
*** ts--define-waver

   #+name: levels-prelude
   #+begin_src elisp

     ;; Because command names are used to store and lookup child levels, we have
     ;; define a macro to generate unqiquely named wavers.  See #153 at
     ;; https://github.com/magit/transient/issues/153
     (defmacro ts--define-waver (name)
       "Define a new suffix named ts--wave-NAME"
       `(transient-define-suffix ,(intern (format "ts--wave-%s" name)) ()
          ,(format "Wave at the user %s" name)
          :transient t
          (interactive)
          (message (format "Waves at %s" (current-time-string)))))

     ;; Each form results in a unique suffix definition.
     (ts--define-waver "surely")
     (ts--define-waver "normally")
     (ts--define-waver "non-essentially")
     (ts--define-waver "definitely")
     (ts--define-waver "eventually")
     (ts--define-waver "hidden")
     (ts--define-waver "surely")

     #+end_src

*** ts-suffix-print-args

   Here's a suffix that reads the transient's infix values, the prefix's
   scope, and any universal argument (=C-u 4= etc).   

   #+name: print-args-prelude
   #+begin_src elisp

     (transient-define-suffix ts-suffix-print-args (prefix-arg)
       "Report the universal argument, prefix's scope, and infix values."
       :transient 'transient--do-call
       (interactive "P")
       (let ((args (transient-args (oref transient-current-prefix command)))
             (scope (oref transient-current-prefix scope)))
         (message "prefix-arg: %s \nprefix's scope value: %s \ntransient-args: %s"
                  prefix-arg scope args)))

   #+end_src
    
* Further Reading

  - [[https://magit.vc/manual/transient.html][*The Transient Manual*]] contains more detailed explanation of behavior.  The examples
    here should allow you to visualize what is being described.  This guide and
    the manual should be your first and second sources.
    
  - [[elisp:(find-library "transient")][*Transient source*]] ([[https://github.com/magit/transient/blob/master/lisp/transient.el][web link]]) is all in one file.  Source code is always
    more accurate than manual descriptions, even if some behavior
    implementations are a bit scattered.
    
  - [[elisp:(find-library "magit")][*Magit source*]] ([[https://github.com/magit/magit/search?q=transient][web link]]) contains numerous examples of transient being used in a big,
    full-feature application.  Search the source for "transient" and you will
    find many prefixes, suffixes, and custom classes.  The smallest examples may
    be harder to find and most combine many behaviors at once.

# Local Variables:
# eval: (require 'org-make-toc)
# before-save-hook: org-make-toc
# org-export-with-properties: ()
# org-export-with-title: t
# End:
